def simulated_annealing(self, table, sequence, kmax, emax, initial_temp):
    """
        initial_table (dict): Table initiale recensant les angles et distances des liaisons.
        kmax (int): Nombre maximum d'itérations.
        emax (float): Valeur seuil de fitness acceptable pour arrêter l'algorithme.
        initial_temp (float): Température initiale pour le recuit simulé.

    """
    # Initialisation
    current_table = table.copy()
    current_fitness = calculate_fitness(self, sequence, current_table)
    best_table = current_table.copy()
    best_fitness = current_fitness
    k = 0

    while k < kmax and current_fitness > emax:
        # Générer un voisin en modifiant une valeur de la table
        neighbor_table = current_table.copy()
        key = random.choice(list(neighbor_table.keys()))  # Choisir une clé aléatoire
        neighbor_table[key] += random.uniform(-1, 1)  # Modifier la valeur de manière aléatoire

        # Calculer la fitness du voisin
        neighbor_fitness = calculate_fitness(self, sequence, neighbor_table)

        # Accepter ou rejeter le voisin
        temperature = initial_temp * (1 - k / kmax)  # Fonction de refroidissement linéaire
        if neighbor_fitness < current_fitness or random.random() < np.exp((current_fitness - neighbor_fitness) / temperature):
            current_table = neighbor_table
            current_fitness = neighbor_fitness

            # Mise à jour du meilleur résultat
            if current_fitness < best_fitness:
                best_table = current_table.copy()
                best_fitness = current_fitness

        # Passer à l'itération suivante
        k += 1

    return best_table


def main():
    # Instancier l'optimiseur
    ga = GeneticOptimizer()

    # Créer un dictionnaire "table" minimaliste
    table_initiale = {
        "liaisonA": [1.0, 2.0, 3.0],
        "liaisonB": [-1.5, 4.0, 0.5],
    }

    # Paramètres du recuit simulé
    kmax = 100
    emax = 1
    initial_temp = 100

    # Lancer le recuit simulé
    best_table = ga.simulated_annealing(
        table=table_initiale,
        sequence,
        kmax=kmax,
        emax=emax,
        initial_temp=initial_temp
    )

    # Afficher les résultats
    print("Table de départ :", table_initiale)
    print("Meilleure table trouvée :", best_table)

    # Calculer et afficher la fitness finale
    best_ind = Individual(best_table)
    best_fitness = ga.calculate_fitness(best_ind, sequence)
    print("Fitness de la meilleure table :", best_fitness)


if __name__ == "__main__":
    main()


