def simulated_annealing(self, table, sequence, kmax, emax, initial_temp):
    """
        initial_temp (dict): Table initiale recensant les températures initiales.
        kmax (int): Nombre maximum d'itérations.
        emax (float): Valeur seuil de fitness acceptable pour arrêter l'algorithme.
        initial_temp (float): Température initiale pour le recuit simulé.
    """
    
    # Initialisation
    current_table = table.copy()
    current_fitness = calculate_fitness(self, sequence, current_table)
    best_table = current_table.copy()
    best_fitness = current_fitness
    k = 0

    while k < kmax and current_fitness > emax:
        # Générer un voisin en modifiant une valeur de la table
        neighbor_table = current_table.copy()
        key = random.choice(list(neighbor_table.keys()))  # Choisir une clé aléatoire
        neighbor_table[key] += random.uniform(-1, 1)  # Modifier la valeur de manière aléatoire

        # Calculer la fitness du voisin
        neighbor_fitness = calculate_fitness(self, sequence, neighbor_table)

        # Accepter ou rejeter le voisin
        temperature = initial_temp * (1 - k / kmax)  # Fonction de refroidissement linéaire
        if neighbor_fitness < current_fitness or random.random() < np.exp((current_fitness - neighbor_fitness) / temperature):
            current_table = neighbor_table
            current_fitness = neighbor_fitness

            # Mise à jour du meilleur résultat
            if current_fitness < best_fitness:
                best_table = current_table.copy()
                best_fitness = current_fitness

        # Passer à l'itération suivante
        k += 1

    return best_table
