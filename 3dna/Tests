import numpy as np
import json
import copy
import os
import unittest
import random
from .genetic_optimizer import GeneticOptimizer

class GeneticOptimizer :
    class Tests : 

        def test_calculate_fitness():
            class MockRotTable:
                def getTable(self):
                    # Tableau factice pour simplifier les tests
                    return {
                        'A': (0.0, 0.0, 1.0),
                        'B': (1.0, 0.0, 0.0),
                        'C': (0.0, 1.0, 0.0)
                    }

            class MockTraj3D:
                def compute(self, sequence, rot_table):
                    # Mock pour simplifier les tests, ignore les séquences
                    pass

                def getTraj(self):
                    # Retourne une trajectoire fermée simple pour les tests
                    return [(0, 0, 0), (1, 1, 1), (0, 0, 0)]

            # Création de l'individu factice
            ind = {
                'A': (0.1, 0.1, 1.1),
                'B': (0.9, 0.1, -0.1),
                'C': (-0.1, 0.9, 0.1)
            }

            # Séquence factice
            sequence = ['A', 'B', 'C', 'A']

            # Mock de la fonction calculate_fitness
            class FitnessTest:
                def calculate_fitness(self, ind, sequence):
                    """Calcule la fitness avec des éléments mockés"""
                    a = 1  # Poids
                    rot_table = MockRotTable()
                    table = rot_table.getTable()
                    traj = MockTraj3D()
                    traj.compute(sequence, rot_table)
                    
                    coords = traj.getTraj()
                    start = np.array(coords[0])
                    end = np.array(coords[-1])
                    end_to_start = np.linalg.norm(end - start)

                    norm = 0
                    for cle in ind:
                        norm += (ind[cle][0] - table[cle][0])**2 + \
                                (ind[cle][1] - table[cle][1])**2 + \
                                (ind[cle][2] - table[cle][2])**2
                    norm = np.sqrt(norm) / len(table)
                    
                    return end_to_start + a * norm

            # Instanciation et appel de la fonction
            fitness_calc = FitnessTest()
            fitness_value = fitness_calc.calculate_fitness(ind, sequence)

            # Vérification des résultats
            assert fitness_value > 0, "La valeur de fitness doit être positive."
            print(f"Test réussi, valeur calculée de fitness : {fitness_value:.4f}")

        def test_crossover():
            # Mock des objets nécessaires
            class MockChild:
                def __init__(self, pair):
                    self.pair = pair
                    self.table = {"AA": (0.1, 0.1, 1.1), "AT": (0.9, 0.1, -0.1), "TA": (-0.1, 0.9, 0.1)}

                def getTable(self):
                    return self.table

                def __setitem__(self, key, value):
                    self.table[key] = value

                def __getitem__(self, key):
                    return self.table[key]

            class MockCrossoverTest:
                def __generate_random_tuple(self, limit, pair):
                    """Génère des points de crossover"""
                    return sorted(np.random.choice(range(len(pair)), limit, replace=False))
            # Création des parents mockés
            parent1 = MockChild(pair=[1, 2, 3])  # Mock de séquence 1
            parent1.table = {
                "AA": (0.1, 0.1, 1.1),
                "AT": (0.9, 0.1, -0.1),
                "TA": (-0.1, 0.9, 0.1)
            }

            parent2 = MockChild(pair=[1, 2, 3])  # Mock de séquence 2
            parent2.table = {
                "AA": (1.0, 1.0, 1.0),
                "AT": (0.0, 0.0, 0.0),
                "TA": (-1.0, -1.0, -1.0)
            }

            # Instanciation et exécution du crossover
            crossover_test = MockCrossoverTest()
            child = crossover_test.crossover(parent1, parent2, type=2)

            # Vérification des résultats
            assert len(child.getTable()) == len(parent1.getTable()), "L'enfant doit avoir autant d'éléments que ses parents"

            print("Test réussi, enfant généré avec succès.")
            print("Génome parent1 :", parent1.getTable())
            print("Génome parent2 :", parent2.getTable())
            print("Génome enfant :", child.getTable())

        # Appel du test
        test_crossover()

        class DummyIndividual:
            """
            Classe simulant un individu avec une méthode getFitness().
            """
            def __init__(self, fitness):
                self.fitness = fitness
            
            def getFitness(self):
                return self.fitness

        
        ####################
        # TESTS UNITAIRES  #
        ####################

        class TestCreateNewGen(unittest.TestCase):
            def setUp(self):
                """
                Initialisation commune à tous les tests : on crée une instance de GA
                et une population factice de DummyIndividual.
                """
                self.population_size = 6
                self.ga = GA(self.population_size)
                
                # Créons une population de 6 individus avec fitness aléatoire
                self.population = [DummyIndividual(random.uniform(0, 10)) 
                                for _ in range(self.population_size)]
            
            def test_selection_best_random(self):
                """Test de la méthode create_new_gen avec type_choosing_parent='best' et type_matching='random'."""
                new_generation = self.ga.create_new_gen(
                    population=self.population,
                    type_choosing_parent="best",
                    type_matching="random",
                    crossover_type=2
                )
                # Vérifions que la taille de la nouvelle génération est égale à population_size
                self.assertEqual(len(new_generation), self.population_size)
                # On peut vérifier que ce sont bien des DummyIndividual
                for indiv in new_generation:
                    self.assertIsInstance(indiv, DummyIndividual)
            
            def test_selection_par_rang_random(self):
                """Test de la méthode create_new_gen avec type_choosing_parent='selection par rang' et type_matching='random'."""
                new_generation = self.ga.create_new_gen(
                    population=self.population,
                    type_choosing_parent="selection par rang",
                    type_matching="random",
                    crossover_type=2
                )
                self.assertEqual(len(new_generation), self.population_size)
            
            def test_selestion_par_roulette_random(self):
                """
                Test de la méthode create_new_gen avec type_choosing_parent='selestion par roulette' (coquille volontaire)
                et type_matching='random'.
                """
                new_generation = self.ga.create_new_gen(
                    population=self.population,
                    type_choosing_parent="selestion par roulette",
                    type_matching="random",
                    crossover_type=2
                )
                self.assertEqual(len(new_generation), self.population_size)
            
            def test_selection_best_tournament(self):
                """Test de la méthode create_new_gen avec type_choosing_parent='best' et type_matching='tournament'."""
                new_generation = self.ga.create_new_gen(
                    population=self.population,
                    type_choosing_parent="best",
                    type_matching="tournament",
                    crossover_type=2
                )
                self.assertEqual(len(new_generation), self.population_size)
                # En option, vérifier qu'il y a bien eu croisement par tournoi 
                # (moins trivial à valider formellement sans logs supplémentaires)

        if __name__ == '__main__':
            unittest.main()

        










        #   Test unhealed
        class DummyIndividual:
            def __init__(self, table):
                self._table = table
            def getTable(self):
                return self._table
            def setTable(self, new_table):
                self._table = new_table

        class DummySelf:
            def calculate_fitness(self, ind, sequence):
                total = 0.0
                for key in ind.getTable():
                    for val in ind.getTable()[key]:
                        total += val**2
                return total


            def test_simulated_annealing_basic_run():
                dummy_obj = DummySelf()
                initial_table = {
                    'liaisonA': [5.0, -2.0, 3.0],
                    'liaisonB': [1.0,  4.0, -1.5]
                }
                ind = DummyIndividual(initial_table)
                
                # Paramètres
                kmax = 50
                emax = 0.01
                initial_temp = 10
                sequence = None  # Pas utilisé ici

                initial_fitness = dummy_obj.calculate_fitness(ind, sequence)
                
                best_table = simulated_annealing(
                    self=dummy_obj,
                    ind=ind,
                    sequence=sequence,
                    kmax=kmax,
                    emax=emax,
                    initial_temp=initial_temp
                )
                
                # Vérifications
                assert isinstance(best_table, dict), "Le résultat doit être un dictionnaire"
                final_fitness = dummy_obj.calculate_fitness(ind, sequence)
                assert final_fitness <= initial_fitness, (
                    f"La fitness finale ({final_fitness}) devrait être inférieure ou égale à la fitness initiale ({initial_fitness})."
                )
